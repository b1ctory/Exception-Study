### weak vs unowned

weak와 unowned는 모두 약한참조를 위한 키워드로, 참조하는 객체의 참조계수에 영향을 주지 않는다. 둘의 차이점을 알아보자.

weak키워드는 optional에 사용할 수 있으며, unowned는 **non-optional인 경우에만 사용 가능**합니다.따라서 unowned는 옵셔널 추출이 필요하지 않지만, **참조하는 객체의 메모리가 해제된 상태에서 객체에 메세지를 보내면 bad access에러가 발생**됩니다.

**if) 참조하는 객체의 참조계수가 0이 되어 메모리가 해제되는 경우,**

> weak는 참조 값이 nil로 대체된다.unowned는 참조 값이 그대로 유지된다..



### strong vs weak vs unowned

- **Strong(강한참조) -** strong은 객체를 소유하여 레퍼런스 카운트가 증가하는 프로퍼티이다. 값 지정 시점에 retain이 되고 참조가 종료되는 시점에 release가 된다.
- **Weak(약한참조) -** weak은 객체를 소유하지 않고 주소값만을 가지고 있는 포인터 개념이다. 자신이 참조는 하지만 weak 메모리를 해제시킬 수 있는 권한은 다른 클래스에 있다. 값 지정시 리테인이 발생하지 않는다. 따라서 릴리즈도 발생하지 않는다. 그래서 언제 어떻게 메모리가 해제될 지 알 수가 없다. 다만 메모리가 해제될 경우 자동으로 레퍼런스가 nil로 초기화를 해 준다. 그렇기 때문에 Weak 속성을 사용하는 객체는 항상 옵셔널타입이여야 한다.
- **Unowned(미소유 참조) -** weak와 매우 비슷한 역할을 한다. 차이점으로는 **Unowned로 선언된 변수는 nil이 될수가 없다.** 그러므로 **Unowned 변수는 옵셔널로 선언되어서는 안된다.** 해제된 메모리 영역을 접근하지 않는다는 확실한 경우에만 사용해야한다.

**어느 상황에 사용하는가**

- **strong** - 레퍼런스 객체가 할당되는 순간 해당 객체의 레퍼런스 카운트를 증가 시킨다. 레퍼런스 카운트를 증가시켜 ARC로 인한 메모리 해제를 피하고 객체를 안전하게 사용하고자 할 때 쓰인다.
- **weak -** 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다. 이 키워드는 Optional 타입에만 적용이 된다. 객체가 ARC에 의해 해제가 되면 nil 값이 할당된다. 대표적으로 **retain cycle에 의해 메모리가 누수되는 문제를 막기 위해 사용되며, iOS 프레임워크에서 대표적인 예로는 Delegate패턴**이 있다**.**
- **unowned -** 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않는다. 그러나 Non-Optional 타입으로 선언되어야 하며, 객체가 ARC에 의해 메모리해제가 되더라도, 해당 객체 값을 존재하는 것으로 인지하며, 해당 객체에 액세스 할 경우 런타임 오류를 발생시킨다. **객체의 라이프 사이클이 명확하고 개발자에 의해 제어 가능이 명확한 경우** , weak Optional 타입 대신 사용하여 좀더 간결한 코딩이 가능하다.